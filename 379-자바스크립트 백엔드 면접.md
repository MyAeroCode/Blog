> # JavaScript

## 프로토타입 언어

#### `프로토타입 언어가 무엇인지 설명해주세요`

클래스 기반 언어에서 상속과 달리 기존 객체를 복제함으로써 상속을 구현하는 객체지향 언어의 한 종류 입니다. 클래스의 개념이 없으므로 `class-less Language`로도 불립니다.

---

---

#### `그럼 자바스크립트에 있는 클래스 문법은 뭔가요?`

ECMA6부터 클래스 문법을 지원하긴 하지만 `문법설탕`에 불과합니다. 클래스 문법을 사용해도 여전히 프로토타입 형태로 동작합니다.

---

---

#### `프로토타입 언어의 특징을 설명해주세요`

클래스 기반 언어와 달리 실행시간에 동적으로 타입이 변경될 수 있습니다. C++의 객체들은 새로운 필드나 메서드가 추가되거나 삭제될 수 없는 것과 대비됩니다.

---

---

#### `프로토타입 언어의 장단점을 설명해주세요`

유연한 타입이 가능하지만, 너무 과한경우 객체의 프로퍼티를 예측할 수 없게됩니다.

---

---

#### `new 키워드로 객체를 생성하는 과정을 설명해주세요`

new 키워드를 사용하여 함수를 호출하면, 먼저 Object를 상속받은 빈 객체가 생성됩니다. 이후에는 빈 객체의 `Prototype-Link`에 호출된 함수의 `Prototype-Object`를 연결하고, new의 결과로 해당 객체가 반환됩니다.

---

---

#### `new 키워드는 객체랑 사용할 수 없나요?`

new의 대상이 되려면 `Prototype-Object`가 존재해야 합니다. 객체는 해당 오브젝트가 존재하지 않기 때문입니다. 반면에 함수는 생성될 때 `Prototype-Object`가 같이 생성되므로 new의 대상이 될 수 있습니다.

---

---

#### `상속받은 필드에 접근할 때, 내부과정을 설명해주세요`

맨 마지막 `Prototype-Object`부터 시작해서 해당 필드가 정의되어 있는지 검사합니다. 해당 객체에서 찾고있는 필드가 발견되었다면 그것을 반환하고, 발견되지 않았다면 상위 `Prototype-Object`로 이동하여 탐색을 반복합니다.

---

**관련 코드 1 :**

```ts
const animal = {
    eats: true,
};
const rabbit = {
    jump: true,
};
rabbit.__proto__ = animal;

console.log(rabbit); // { jump: true } rabbit에 eats는 없다!
console.log(rabbit.jump); // true.
console.log(rabbit.eats); // true. why?
```

---

**관련 코드 2 :**

```ts
function Animal() {
    this.eats = true;
}
function Rabbit() {
    this.__proto__ = new Animal();
    this.jump = true;
}

const rabbit = new Rabbit(); // { jump: true }
console.log(rabbit.jump); // true.
console.log(rabbit.eats); // true. why?

console.log(rabbit.sleep); // undefined
Animal.prototype.sleep = true;
console.log(rabbit.sleep); // true. why?
```

---

---

#### `for in 구문으로 상속된 프로퍼티의 키도 볼 수 있나요?`

네. 볼 수 있습니다.

```ts
function Animal() {
    this.eats = true;
}
function Rabbit() {
    this.__proto__ = new Animal();
    this.jump = true;
}
const rabbit = new Rabbit();
for (const key in rabbit) {
    console.log(key); // "eats", "jump"
}
```

---

---

#### `상속된 프로퍼티를 제외한 프로퍼티 목록을 알려면 어떻게 해야하나요?`

`Object.getOwnPropertyNames`를 사용합니다.

---

---

## `이전 버전에서의 코딩`

#### `클래스 문법 없이 Static Property를 구현하려면 어떻게 해야하나요?`

함수에 직접 프로퍼티를 넣으면 됩니다.

```ts
function A() {}
A.x = 1;

const a = new A();
console.log(a.x); // undefined
console.log(A.x); // 1;
```

---

---

#### `클래스 문법 없이 Private Property를 구현하려면 어떻게 해야하나요?`

클로저를 사용하면 됩니다.

```ts
function A() {
    let x = 999;
    function A() {
        this.getX = function () {
            return x;
        };
    }
    return new A();
}

const a = new A();
console.log(a.x); // undefined
console.log(a.getX()); // 999
```

---

---

## ECMA 버전

---

# TypeScript

---

# Node.JS
